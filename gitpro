#!/usr/bin/env python3

import os
import re
import sys
import subprocess
import ast
from configparser import ConfigParser


def run(cmd):
    return subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode().strip()


def get_repo_root():
    try:
        return run(["git", "rev-parse", "--show-toplevel"])
    except subprocess.CalledProcessError:
        return None


def get_repo_url(remote_name="origin"):
    try:
        return run(["git", "remote", "get-url", remote_name])
    except subprocess.CalledProcessError:
        return None


def load_config():
    config_path = os.path.expanduser("~/.gitpro")
    if os.path.exists(config_path):
        parser = ConfigParser()
        parser.read(config_path)
        return parser
    return None


def expand(val):
    return os.path.expanduser(val.strip('"'))


def parse_list(val):
    return ast.literal_eval(val)


def select_profile(cfg, repo_url):
    for section in cfg.sections():
        if section == "default":
            continue

        if cfg.has_option(section, "matchingRepos"):
            patterns = parse_list(cfg.get(section, "matchingRepos"))
            for p in patterns:
                if re.search(p, repo_url):
                    return section, p

    return "default", None


def find_url_in_args(args):
    for arg in args:
        if re.match(r'(git@|https?://|ssh://)', arg):
            return arg
    return None


def find_remote_in_args(args):
    """Find the remote name in git command arguments.
    For push/pull/fetch commands, the remote is typically the first argument after the command.
    """
    if len(args) < 2:
        return None
    
    command = args[0]
    if command in ['push', 'pull', 'fetch']:
        # The remote name is usually the first argument after the command
        # unless it starts with a dash (option flag)
        potential_remote = args[1]
        if not potential_remote.startswith('-'):
            return potential_remote
    
    return None


def apply_git_config(profile, cfg):
    email = cfg.get(profile, "email").strip('"')
    name = cfg.get(profile, "userName").strip('"')

    subprocess.check_call(["git", "config", "--local", "user.email", email])
    subprocess.check_call(["git", "config", "--local", "user.name", name])


def main():
    try:
        if len(sys.argv) < 2:
            result = subprocess.run(['git'])
            sys.exit(result.returncode)
        
        git_args = sys.argv[1:]
        remote_commands = ['clone', 'pull', 'push', 'fetch']
        url = find_url_in_args(git_args)
        cfg = load_config()
        
        if cfg and git_args[0] in remote_commands:
            if not url:
                # Detect which remote is being used in the command
                remote_name = find_remote_in_args(git_args)
                if remote_name:
                    url = get_repo_url(remote_name)
                if not url:
                    # Fallback to origin if remote not found or not specified
                    url = get_repo_url("origin")
            if url:
                profile, matched_pattern = select_profile(cfg, url)
                
                # Show repository URL first
                print(f"gitpro: Repository URL: {url}", file=sys.stderr)
                
                # Only use custom SSH key if profile is not default and has sshKeyPath
                env = os.environ.copy()
                if profile != "default" and cfg.has_option(profile, "sshKeyPath"):
                    key = expand(cfg.get(profile, "sshKeyPath"))
                    ssh_cmd = f"ssh -i {key} -o IdentitiesOnly=yes"
                    env['GIT_SSH_COMMAND'] = ssh_cmd
                    
                    print(f"gitpro: Using profile '{profile}'", file=sys.stderr)
                    if matched_pattern:
                        print(f"gitpro: Matched pattern: {matched_pattern}", file=sys.stderr)
                    print(f"gitpro: SSH key: {key}", file=sys.stderr)
                
                result = subprocess.run(['git'] + git_args, env=env)
                
                if git_args[0] == 'clone' and result.returncode == 0:
                    # Parse cloned directory
                    if len(git_args) > 2:
                        cloned_dir = git_args[2]
                    else:
                        cloned_dir = url.split('/')[-1].replace('.git', '')
                    os.chdir(cloned_dir)
                    apply_git_config(profile, cfg)
                
                sys.exit(result.returncode)
        
        # No config or not a remote command or no url
        result = subprocess.run(['git'] + git_args)
        sys.exit(result.returncode)
    except KeyboardInterrupt:
        sys.exit(130)


if __name__ == "__main__":
    main()
